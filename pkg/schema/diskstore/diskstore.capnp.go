// Code generated by capnpc-go. DO NOT EDIT.

package diskstore

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	strconv "strconv"
	protocol "zenhack.net/go/ocap-md/pkg/schema/protocol"
)

// Constants defined in diskstore.capnp.
const (
	StorageFormatVersion = uint32(1)
)

type Manifest struct{ capnp.Struct }
type Manifest_lastLog Manifest

// Manifest_TypeID is the unique identifier for the type Manifest.
const Manifest_TypeID = 0xe09672577fe40a61

func NewManifest(s *capnp.Segment) (Manifest, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2})
	return Manifest{st}, err
}

func NewRootManifest(s *capnp.Segment) (Manifest, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2})
	return Manifest{st}, err
}

func ReadRootManifest(msg *capnp.Message) (Manifest, error) {
	root, err := msg.Root()
	return Manifest{root.Struct()}, err
}

func (s Manifest) String() string {
	str, _ := text.Marshal(0xe09672577fe40a61, s.Struct)
	return str
}

func (s Manifest) FormatVersion() uint32 {
	return s.Struct.Uint32(16)
}

func (s Manifest) SetFormatVersion(v uint32) {
	s.Struct.SetUint32(16, v)
}

func (s Manifest) BlobMap() (Addr, error) {
	p, err := s.Struct.Ptr(0)
	return Addr{Struct: p.Struct()}, err
}

func (s Manifest) HasBlobMap() bool {
	return s.Struct.HasPtr(0)
}

func (s Manifest) SetBlobMap(v Addr) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBlobMap sets the blobMap field to a newly
// allocated Addr struct, preferring placement in s's segment.
func (s Manifest) NewBlobMap() (Addr, error) {
	ss, err := NewAddr(s.Struct.Segment())
	if err != nil {
		return Addr{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Manifest) Root() (protocol.ContentId, error) {
	p, err := s.Struct.Ptr(1)
	return protocol.ContentId{Struct: p.Struct()}, err
}

func (s Manifest) HasRoot() bool {
	return s.Struct.HasPtr(1)
}

func (s Manifest) SetRoot(v protocol.ContentId) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewRoot sets the root field to a newly
// allocated protocol.ContentId struct, preferring placement in s's segment.
func (s Manifest) NewRoot() (protocol.ContentId, error) {
	ss, err := protocol.NewContentId(s.Struct.Segment())
	if err != nil {
		return protocol.ContentId{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Manifest) LastLog() Manifest_lastLog { return Manifest_lastLog(s) }

func (s Manifest_lastLog) Size() uint64 {
	return s.Struct.Uint64(0)
}

func (s Manifest_lastLog) SetSize(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s Manifest_lastLog) Number() uint64 {
	return s.Struct.Uint64(8)
}

func (s Manifest_lastLog) SetNumber(v uint64) {
	s.Struct.SetUint64(8, v)
}

// Manifest_List is a list of Manifest.
type Manifest_List = capnp.StructList[Manifest]

// NewManifest creates a new list of Manifest.
func NewManifest_List(s *capnp.Segment, sz int32) (Manifest_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2}, sz)
	return capnp.StructList[Manifest]{l}, err
}

// Manifest_Future is a wrapper for a Manifest promised by a client call.
type Manifest_Future struct{ *capnp.Future }

func (p Manifest_Future) Struct() (Manifest, error) {
	s, err := p.Future.Struct()
	return Manifest{s}, err
}

func (p Manifest_Future) BlobMap() Addr_Future {
	return Addr_Future{Future: p.Future.Field(0, nil)}
}

func (p Manifest_Future) Root() protocol.ContentId_Future {
	return protocol.ContentId_Future{Future: p.Future.Field(1, nil)}
}

func (p Manifest_Future) LastLog() Manifest_lastLog_Future { return Manifest_lastLog_Future{p.Future} }

// Manifest_lastLog_Future is a wrapper for a Manifest_lastLog promised by a client call.
type Manifest_lastLog_Future struct{ *capnp.Future }

func (p Manifest_lastLog_Future) Struct() (Manifest_lastLog, error) {
	s, err := p.Future.Struct()
	return Manifest_lastLog{s}, err
}

type Addr struct{ capnp.Struct }

// Addr_TypeID is the unique identifier for the type Addr.
const Addr_TypeID = 0xe45f1d3ad96f0c55

func NewAddr(s *capnp.Segment) (Addr, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return Addr{st}, err
}

func NewRootAddr(s *capnp.Segment) (Addr, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return Addr{st}, err
}

func ReadRootAddr(msg *capnp.Message) (Addr, error) {
	root, err := msg.Root()
	return Addr{root.Struct()}, err
}

func (s Addr) String() string {
	str, _ := text.Marshal(0xe45f1d3ad96f0c55, s.Struct)
	return str
}

func (s Addr) LogNumber() uint64 {
	return s.Struct.Uint64(16)
}

func (s Addr) SetLogNumber(v uint64) {
	s.Struct.SetUint64(16, v)
}

func (s Addr) Offset() uint64 {
	return s.Struct.Uint64(0)
}

func (s Addr) SetOffset(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s Addr) Length() uint32 {
	return s.Struct.Uint32(8)
}

func (s Addr) SetLength(v uint32) {
	s.Struct.SetUint32(8, v)
}

// Addr_List is a list of Addr.
type Addr_List = capnp.StructList[Addr]

// NewAddr creates a new list of Addr.
func NewAddr_List(s *capnp.Segment, sz int32) (Addr_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0}, sz)
	return capnp.StructList[Addr]{l}, err
}

// Addr_Future is a wrapper for a Addr promised by a client call.
type Addr_Future struct{ *capnp.Future }

func (p Addr_Future) Struct() (Addr, error) {
	s, err := p.Future.Struct()
	return Addr{s}, err
}

type LogEntry struct{ capnp.Struct }
type LogEntry_Which uint16

const (
	LogEntry_Which_blob      LogEntry_Which = 0
	LogEntry_Which_indexNode LogEntry_Which = 1
)

func (w LogEntry_Which) String() string {
	const s = "blobindexNode"
	switch w {
	case LogEntry_Which_blob:
		return s[0:4]
	case LogEntry_Which_indexNode:
		return s[4:13]

	}
	return "LogEntry_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// LogEntry_TypeID is the unique identifier for the type LogEntry.
const LogEntry_TypeID = 0xd848462725353ce8

func NewLogEntry(s *capnp.Segment) (LogEntry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return LogEntry{st}, err
}

func NewRootLogEntry(s *capnp.Segment) (LogEntry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return LogEntry{st}, err
}

func ReadRootLogEntry(msg *capnp.Message) (LogEntry, error) {
	root, err := msg.Root()
	return LogEntry{root.Struct()}, err
}

func (s LogEntry) String() string {
	str, _ := text.Marshal(0xd848462725353ce8, s.Struct)
	return str
}

func (s LogEntry) Which() LogEntry_Which {
	return LogEntry_Which(s.Struct.Uint16(0))
}
func (s LogEntry) Blob() ([]byte, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != blob")
	}
	p, err := s.Struct.Ptr(0)
	return []byte(p.Data()), err
}

func (s LogEntry) HasBlob() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s LogEntry) SetBlob(v []byte) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetData(0, v)
}

func (s LogEntry) IndexNode() (TrieMap, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != indexNode")
	}
	p, err := s.Struct.Ptr(0)
	return TrieMap{Struct: p.Struct()}, err
}

func (s LogEntry) HasIndexNode() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s LogEntry) SetIndexNode(v TrieMap) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIndexNode sets the indexNode field to a newly
// allocated TrieMap struct, preferring placement in s's segment.
func (s LogEntry) NewIndexNode() (TrieMap, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewTrieMap(s.Struct.Segment())
	if err != nil {
		return TrieMap{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// LogEntry_List is a list of LogEntry.
type LogEntry_List = capnp.StructList[LogEntry]

// NewLogEntry creates a new list of LogEntry.
func NewLogEntry_List(s *capnp.Segment, sz int32) (LogEntry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[LogEntry]{l}, err
}

// LogEntry_Future is a wrapper for a LogEntry promised by a client call.
type LogEntry_Future struct{ *capnp.Future }

func (p LogEntry_Future) Struct() (LogEntry, error) {
	s, err := p.Future.Struct()
	return LogEntry{s}, err
}

func (p LogEntry_Future) IndexNode() TrieMap_Future {
	return TrieMap_Future{Future: p.Future.Field(0, nil)}
}

type TrieMap struct{ capnp.Struct }
type TrieMap_leaf TrieMap
type TrieMap_Which uint16

const (
	TrieMap_Which_leaf     TrieMap_Which = 0
	TrieMap_Which_branches TrieMap_Which = 1
)

func (w TrieMap_Which) String() string {
	const s = "leafbranches"
	switch w {
	case TrieMap_Which_leaf:
		return s[0:4]
	case TrieMap_Which_branches:
		return s[4:12]

	}
	return "TrieMap_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// TrieMap_TypeID is the unique identifier for the type TrieMap.
const TrieMap_TypeID = 0xcc6f8e43c0d837f7

func NewTrieMap(s *capnp.Segment) (TrieMap, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return TrieMap{st}, err
}

func NewRootTrieMap(s *capnp.Segment) (TrieMap, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return TrieMap{st}, err
}

func ReadRootTrieMap(msg *capnp.Message) (TrieMap, error) {
	root, err := msg.Root()
	return TrieMap{root.Struct()}, err
}

func (s TrieMap) String() string {
	str, _ := text.Marshal(0xcc6f8e43c0d837f7, s.Struct)
	return str
}

func (s TrieMap) Which() TrieMap_Which {
	return TrieMap_Which(s.Struct.Uint16(0))
}
func (s TrieMap) Leaf() TrieMap_leaf { return TrieMap_leaf(s) }

func (s TrieMap) SetLeaf() {
	s.Struct.SetUint16(0, 0)
}

func (s TrieMap_leaf) Prefix() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return []byte(p.Data()), err
}

func (s TrieMap_leaf) HasPrefix() bool {
	return s.Struct.HasPtr(0)
}

func (s TrieMap_leaf) SetPrefix(v []byte) error {
	return s.Struct.SetData(0, v)
}

func (s TrieMap_leaf) Addr() (Addr, error) {
	p, err := s.Struct.Ptr(1)
	return Addr{Struct: p.Struct()}, err
}

func (s TrieMap_leaf) HasAddr() bool {
	return s.Struct.HasPtr(1)
}

func (s TrieMap_leaf) SetAddr(v Addr) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewAddr sets the addr field to a newly
// allocated Addr struct, preferring placement in s's segment.
func (s TrieMap_leaf) NewAddr() (Addr, error) {
	ss, err := NewAddr(s.Struct.Segment())
	if err != nil {
		return Addr{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s TrieMap) Branches() (Addr_List, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != branches")
	}
	p, err := s.Struct.Ptr(0)
	return Addr_List{List: p.List()}, err
}

func (s TrieMap) HasBranches() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s TrieMap) SetBranches(v Addr_List) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewBranches sets the branches field to a newly
// allocated Addr_List, preferring placement in s's segment.
func (s TrieMap) NewBranches(n int32) (Addr_List, error) {
	s.Struct.SetUint16(0, 1)
	l, err := NewAddr_List(s.Struct.Segment(), n)
	if err != nil {
		return Addr_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// TrieMap_List is a list of TrieMap.
type TrieMap_List = capnp.StructList[TrieMap]

// NewTrieMap creates a new list of TrieMap.
func NewTrieMap_List(s *capnp.Segment, sz int32) (TrieMap_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[TrieMap]{l}, err
}

// TrieMap_Future is a wrapper for a TrieMap promised by a client call.
type TrieMap_Future struct{ *capnp.Future }

func (p TrieMap_Future) Struct() (TrieMap, error) {
	s, err := p.Future.Struct()
	return TrieMap{s}, err
}

func (p TrieMap_Future) Leaf() TrieMap_leaf_Future { return TrieMap_leaf_Future{p.Future} }

// TrieMap_leaf_Future is a wrapper for a TrieMap_leaf promised by a client call.
type TrieMap_leaf_Future struct{ *capnp.Future }

func (p TrieMap_leaf_Future) Struct() (TrieMap_leaf, error) {
	s, err := p.Future.Struct()
	return TrieMap_leaf{s}, err
}

func (p TrieMap_leaf_Future) Addr() Addr_Future {
	return Addr_Future{Future: p.Future.Field(1, nil)}
}

const schema_dc976fcd6fee6223 = "x\xdat\x93Oh#e\x18\xc6\xdf\xe7\xfd\xa6&-" +
	"M3\xc3D\xd0C\x11\xd1\xd2Zj\xa9T\xb1\x04\xa1" +
	"\xb5\xda\xa2\x92\x94|\xd6?\x15*:i&\xc9`:" +
	"\x13g\xa6X\x0b\xa5\x88\x08\x9e\x04/\xea\xc5\x83\x07\x85" +
	"z\xe9\xd9\x83b\x17v\x0f\xa5{[\xd8.\xec\xb2\xbb" +
	"\xd0e\xff\x1c\xf6\xba\xb0\x87\xce\xf2M\x92I\xc8\xee\xde" +
	"\xf2}<_~\xcf\xfb\xbc\xcf\xcc\xeccA{-s" +
	"Y#\x96s\x03\xcfD\x8bk\xd7'.\x1c\xfe\xfe3" +
	"\x19\xba\x16\xbdT\xbe\xef]\xf4~\xbdJ\x84Y\xc9\x93" +
	"0-N\x11\xad\xae\xb3\xc0j\x9d\x19D\xd1\x8f7\xbf" +
	"7w\xcfj\xbf\x91|\x0e\x88\x1e\xbcy\xf2\xff;?" +
	"y\xc7\xf4,\xa7@d~\xc6\xf7\x08\xe6\xe7\xfc\x0d!" +
	":\xd6\xc7\xbf\xfe\xef\x87\xdc\x01\xc9\xe7!\"k\xe8t" +
	"\xefS\xff\x97\x1bm\xe5\xec?<\x04\x82y\x18K\x93" +
	"\xbf\x91:\xd0u\xb1\xc4)&2G\xc59sL\xa4" +
	"\x88\xcc\x17\x85R\xdfy\xeb\x8d\xb1\xf1\xe5\xf7N\xfa\xd5" +
	"\x88\xd5[\xe2\xc8\xfc.V\xef\xc6\xea\x04,u\x88\xae" +
	"z@Mf^\x13G\xe6\xddX|K\xdc&D\x1f" +
	"\x0f{W\xf2\xa3_\x9c\xf6\x895\xa5\xf8C\xfb\xdb\xdc" +
	"\x8f\x7f\xfd\xa9\x1d\xd0JTq\x82\xaf\x82\xd0\xf3\x85=" +
	"\xbda5\xddf^\x1d\xac\x9a\xbd\xec\xf9\x9bV\xf8\x89" +
	"\xedg\x03\xc7sK\x00\xd2\xc4F\x1a\x84\xe4\x09w\x9e" +
	"|\xe4;v\xd1jNg\x1b\xb6U\x95i\xa1\x11i" +
	" 2^\xc9\x13\xc9\x97\x05\xe4\x0c\xc3\x00rP\x97\xaf" +
	"N\x12\xc9\x09\x01\xf9:c\xbe\xe9\xdbUg\x1b\x19b" +
	"d\x08Y\xabR\xf1\xa1w\xfd\x13\xa0\xf7\x00\x13\x8fE" +
	"\xcbu\xaav\x10N7\xac ,x5\xa2\x165\x07" +
	"V\xd8\xc9>\xacP\xd8|\x17\x9b\x0d\x9c\x1d\x1b\x83\xc4" +
	"\x18$\xcc\xbb[\x9be\xdb\xef\x1c\x9f:\x1d\x95\x00E" +
	"\x19\x8e\"\xa0[ E\xe3\x0c\xce\xa2\x16\xdb\xf8\x80H" +
	"\xea\x02r\x8a\x11\xc7\x11\x95}\xcb\xdd\xa8\xdb\x01\x11a" +
	"\x84P\x12\xe8\x9bp\xe4I\xd0\x82W[rC\xff[" +
	"\xea\xc1\xb62\xed\x19\xae\x85\x8dC\xfd\x90HN\x09\xc8" +
	"9F\xb6\xdc\xf0\xca\x9dH#\xc7\xad\xd8\xdb+^\x85" +
	"`C\xefV\xb4/Y\xeeO\xb6\xc5\xd5\x85\x06\xc4X" +
	"k\x91H\xae\x0b\xc8:\xc3\xe0\xf6*m\xe5\xe5K\x01" +
	"\xd9`@\xa0\xe7c1\x9cEb]\xcbA#2\xa4" +
	"O$K\x02r\x9d\xb1\xa7\xcc\x15\xad\xe6\xe3[\xce\xfa" +
	"\x9e\x17B\x8f\xfe\xf2\x1f\xd6/\xed\xfc{\xbe}\xbd\xd7" +
	"^qTm\x17\x92^\xf0U#U\x1d\x91\xee\x19\x01" +
	"\x9d\x11\xb2oW*\xber?\x9c\xb8_R\xcb_\x10" +
	"\x90\x05\xe5\x9e[\xee\xdfW\x97\xef\x0a\xc8\x12C\xe7\xd6" +
	"\xfa\x8a*\xc7\x82\x80\\c\xcc{\xd5j`\x87IO" +
	"\x1a\xb6[\x0b\xeb\x09\xb7\xe1\xd5VTs\x08Iw\x1e" +
	"\x05\x00\x00\xff\xffCK,\xe3"

func init() {
	schemas.Register(schema_dc976fcd6fee6223,
		0x919dc1c628df5842,
		0x9867fe7d1383e188,
		0xaf1485be712710cc,
		0xcc6f8e43c0d837f7,
		0xd848462725353ce8,
		0xe09672577fe40a61,
		0xe45f1d3ad96f0c55)
}
