// Code generated by capnpc-go. DO NOT EDIT.

package diskstore

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	strconv "strconv"
	protocol "zenhack.net/go/ocap-md/pkg/schema/protocol"
)

// Constants defined in diskstore.capnp.
const (
	StorageFormatVersion = uint32(1)
)

type Manifest struct{ capnp.Struct }
type Manifest_lastLog Manifest

// Manifest_TypeID is the unique identifier for the type Manifest.
const Manifest_TypeID = 0xe09672577fe40a61

func NewManifest(s *capnp.Segment) (Manifest, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2})
	return Manifest{st}, err
}

func NewRootManifest(s *capnp.Segment) (Manifest, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2})
	return Manifest{st}, err
}

func ReadRootManifest(msg *capnp.Message) (Manifest, error) {
	root, err := msg.Root()
	return Manifest{root.Struct()}, err
}

func (s Manifest) String() string {
	str, _ := text.Marshal(0xe09672577fe40a61, s.Struct)
	return str
}

func (s Manifest) FormatVersion() uint32 {
	return s.Struct.Uint32(16)
}

func (s Manifest) SetFormatVersion(v uint32) {
	s.Struct.SetUint32(16, v)
}

func (s Manifest) BlobMap() (Addr, error) {
	p, err := s.Struct.Ptr(0)
	return Addr{Struct: p.Struct()}, err
}

func (s Manifest) HasBlobMap() bool {
	return s.Struct.HasPtr(0)
}

func (s Manifest) SetBlobMap(v Addr) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBlobMap sets the blobMap field to a newly
// allocated Addr struct, preferring placement in s's segment.
func (s Manifest) NewBlobMap() (Addr, error) {
	ss, err := NewAddr(s.Struct.Segment())
	if err != nil {
		return Addr{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Manifest) Root() (protocol.ContentId, error) {
	p, err := s.Struct.Ptr(1)
	return protocol.ContentId{Struct: p.Struct()}, err
}

func (s Manifest) HasRoot() bool {
	return s.Struct.HasPtr(1)
}

func (s Manifest) SetRoot(v protocol.ContentId) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewRoot sets the root field to a newly
// allocated protocol.ContentId struct, preferring placement in s's segment.
func (s Manifest) NewRoot() (protocol.ContentId, error) {
	ss, err := protocol.NewContentId(s.Struct.Segment())
	if err != nil {
		return protocol.ContentId{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Manifest) LastLog() Manifest_lastLog { return Manifest_lastLog(s) }

func (s Manifest_lastLog) Size() uint64 {
	return s.Struct.Uint64(0)
}

func (s Manifest_lastLog) SetSize(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s Manifest_lastLog) Number() uint64 {
	return s.Struct.Uint64(8)
}

func (s Manifest_lastLog) SetNumber(v uint64) {
	s.Struct.SetUint64(8, v)
}

// Manifest_List is a list of Manifest.
type Manifest_List = capnp.StructList[Manifest]

// NewManifest creates a new list of Manifest.
func NewManifest_List(s *capnp.Segment, sz int32) (Manifest_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2}, sz)
	return capnp.StructList[Manifest]{List: l}, err
}

// Manifest_Future is a wrapper for a Manifest promised by a client call.
type Manifest_Future struct{ *capnp.Future }

func (p Manifest_Future) Struct() (Manifest, error) {
	s, err := p.Future.Struct()
	return Manifest{s}, err
}

func (p Manifest_Future) BlobMap() Addr_Future {
	return Addr_Future{Future: p.Future.Field(0, nil)}
}

func (p Manifest_Future) Root() protocol.ContentId_Future {
	return protocol.ContentId_Future{Future: p.Future.Field(1, nil)}
}

func (p Manifest_Future) LastLog() Manifest_lastLog_Future { return Manifest_lastLog_Future{p.Future} }

// Manifest_lastLog_Future is a wrapper for a Manifest_lastLog promised by a client call.
type Manifest_lastLog_Future struct{ *capnp.Future }

func (p Manifest_lastLog_Future) Struct() (Manifest_lastLog, error) {
	s, err := p.Future.Struct()
	return Manifest_lastLog{s}, err
}

type Addr struct{ capnp.Struct }

// Addr_TypeID is the unique identifier for the type Addr.
const Addr_TypeID = 0xe45f1d3ad96f0c55

func NewAddr(s *capnp.Segment) (Addr, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return Addr{st}, err
}

func NewRootAddr(s *capnp.Segment) (Addr, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return Addr{st}, err
}

func ReadRootAddr(msg *capnp.Message) (Addr, error) {
	root, err := msg.Root()
	return Addr{root.Struct()}, err
}

func (s Addr) String() string {
	str, _ := text.Marshal(0xe45f1d3ad96f0c55, s.Struct)
	return str
}

func (s Addr) LogNumber() uint64 {
	return s.Struct.Uint64(16)
}

func (s Addr) SetLogNumber(v uint64) {
	s.Struct.SetUint64(16, v)
}

func (s Addr) Offset() uint64 {
	return s.Struct.Uint64(0)
}

func (s Addr) SetOffset(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s Addr) Length() uint32 {
	return s.Struct.Uint32(8)
}

func (s Addr) SetLength(v uint32) {
	s.Struct.SetUint32(8, v)
}

// Addr_List is a list of Addr.
type Addr_List = capnp.StructList[Addr]

// NewAddr creates a new list of Addr.
func NewAddr_List(s *capnp.Segment, sz int32) (Addr_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0}, sz)
	return capnp.StructList[Addr]{List: l}, err
}

// Addr_Future is a wrapper for a Addr promised by a client call.
type Addr_Future struct{ *capnp.Future }

func (p Addr_Future) Struct() (Addr, error) {
	s, err := p.Future.Struct()
	return Addr{s}, err
}

type LogEntry struct{ capnp.Struct }
type LogEntry_blob LogEntry
type LogEntry_Which uint16

const (
	LogEntry_Which_blob      LogEntry_Which = 0
	LogEntry_Which_indexNode LogEntry_Which = 1
)

func (w LogEntry_Which) String() string {
	const s = "blobindexNode"
	switch w {
	case LogEntry_Which_blob:
		return s[0:4]
	case LogEntry_Which_indexNode:
		return s[4:13]

	}
	return "LogEntry_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// LogEntry_TypeID is the unique identifier for the type LogEntry.
const LogEntry_TypeID = 0xd848462725353ce8

func NewLogEntry(s *capnp.Segment) (LogEntry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return LogEntry{st}, err
}

func NewRootLogEntry(s *capnp.Segment) (LogEntry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return LogEntry{st}, err
}

func ReadRootLogEntry(msg *capnp.Message) (LogEntry, error) {
	root, err := msg.Root()
	return LogEntry{root.Struct()}, err
}

func (s LogEntry) String() string {
	str, _ := text.Marshal(0xd848462725353ce8, s.Struct)
	return str
}

func (s LogEntry) Which() LogEntry_Which {
	return LogEntry_Which(s.Struct.Uint16(0))
}
func (s LogEntry) Blob() LogEntry_blob { return LogEntry_blob(s) }

func (s LogEntry) SetBlob() {
	s.Struct.SetUint16(0, 0)
}

func (s LogEntry_blob) Segment() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return []byte(p.Data()), err
}

func (s LogEntry_blob) HasSegment() bool {
	return s.Struct.HasPtr(0)
}

func (s LogEntry_blob) SetSegment(v []byte) error {
	return s.Struct.SetData(0, v)
}

func (s LogEntry_blob) Compression() CompressionScheme {
	return CompressionScheme(s.Struct.Uint16(2))
}

func (s LogEntry_blob) SetCompression(v CompressionScheme) {
	s.Struct.SetUint16(2, uint16(v))
}

func (s LogEntry_blob) Packed() bool {
	return s.Struct.Bit(32)
}

func (s LogEntry_blob) SetPacked(v bool) {
	s.Struct.SetBit(32, v)
}

func (s LogEntry) IndexNode() (TrieMap, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != indexNode")
	}
	p, err := s.Struct.Ptr(0)
	return TrieMap{Struct: p.Struct()}, err
}

func (s LogEntry) HasIndexNode() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s LogEntry) SetIndexNode(v TrieMap) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewIndexNode sets the indexNode field to a newly
// allocated TrieMap struct, preferring placement in s's segment.
func (s LogEntry) NewIndexNode() (TrieMap, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewTrieMap(s.Struct.Segment())
	if err != nil {
		return TrieMap{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// LogEntry_List is a list of LogEntry.
type LogEntry_List = capnp.StructList[LogEntry]

// NewLogEntry creates a new list of LogEntry.
func NewLogEntry_List(s *capnp.Segment, sz int32) (LogEntry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[LogEntry]{List: l}, err
}

// LogEntry_Future is a wrapper for a LogEntry promised by a client call.
type LogEntry_Future struct{ *capnp.Future }

func (p LogEntry_Future) Struct() (LogEntry, error) {
	s, err := p.Future.Struct()
	return LogEntry{s}, err
}

func (p LogEntry_Future) Blob() LogEntry_blob_Future { return LogEntry_blob_Future{p.Future} }

// LogEntry_blob_Future is a wrapper for a LogEntry_blob promised by a client call.
type LogEntry_blob_Future struct{ *capnp.Future }

func (p LogEntry_blob_Future) Struct() (LogEntry_blob, error) {
	s, err := p.Future.Struct()
	return LogEntry_blob{s}, err
}

func (p LogEntry_Future) IndexNode() TrieMap_Future {
	return TrieMap_Future{Future: p.Future.Field(0, nil)}
}

type CompressionScheme uint16

// CompressionScheme_TypeID is the unique identifier for the type CompressionScheme.
const CompressionScheme_TypeID = 0xa9e5a7728baf3d2e

// Values of CompressionScheme.
const (
	CompressionScheme_none CompressionScheme = 0
	CompressionScheme_xz   CompressionScheme = 1
)

// String returns the enum's constant name.
func (c CompressionScheme) String() string {
	switch c {
	case CompressionScheme_none:
		return "none"
	case CompressionScheme_xz:
		return "xz"

	default:
		return ""
	}
}

// CompressionSchemeFromString returns the enum value with a name,
// or the zero value if there's no such value.
func CompressionSchemeFromString(c string) CompressionScheme {
	switch c {
	case "none":
		return CompressionScheme_none
	case "xz":
		return CompressionScheme_xz

	default:
		return 0
	}
}

type CompressionScheme_List = capnp.EnumList[CompressionScheme]

func NewCompressionScheme_List(s *capnp.Segment, sz int32) (CompressionScheme_List, error) {
	return capnp.NewEnumList[CompressionScheme](s, sz)
}

type TrieMap struct{ capnp.Struct }
type TrieMap_leaf TrieMap
type TrieMap_Which uint16

const (
	TrieMap_Which_leaf     TrieMap_Which = 0
	TrieMap_Which_branches TrieMap_Which = 1
)

func (w TrieMap_Which) String() string {
	const s = "leafbranches"
	switch w {
	case TrieMap_Which_leaf:
		return s[0:4]
	case TrieMap_Which_branches:
		return s[4:12]

	}
	return "TrieMap_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// TrieMap_TypeID is the unique identifier for the type TrieMap.
const TrieMap_TypeID = 0xcc6f8e43c0d837f7

func NewTrieMap(s *capnp.Segment) (TrieMap, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return TrieMap{st}, err
}

func NewRootTrieMap(s *capnp.Segment) (TrieMap, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return TrieMap{st}, err
}

func ReadRootTrieMap(msg *capnp.Message) (TrieMap, error) {
	root, err := msg.Root()
	return TrieMap{root.Struct()}, err
}

func (s TrieMap) String() string {
	str, _ := text.Marshal(0xcc6f8e43c0d837f7, s.Struct)
	return str
}

func (s TrieMap) Which() TrieMap_Which {
	return TrieMap_Which(s.Struct.Uint16(0))
}
func (s TrieMap) Leaf() TrieMap_leaf { return TrieMap_leaf(s) }

func (s TrieMap) SetLeaf() {
	s.Struct.SetUint16(0, 0)
}

func (s TrieMap_leaf) Prefix() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return []byte(p.Data()), err
}

func (s TrieMap_leaf) HasPrefix() bool {
	return s.Struct.HasPtr(0)
}

func (s TrieMap_leaf) SetPrefix(v []byte) error {
	return s.Struct.SetData(0, v)
}

func (s TrieMap_leaf) Addr() (Addr, error) {
	p, err := s.Struct.Ptr(1)
	return Addr{Struct: p.Struct()}, err
}

func (s TrieMap_leaf) HasAddr() bool {
	return s.Struct.HasPtr(1)
}

func (s TrieMap_leaf) SetAddr(v Addr) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewAddr sets the addr field to a newly
// allocated Addr struct, preferring placement in s's segment.
func (s TrieMap_leaf) NewAddr() (Addr, error) {
	ss, err := NewAddr(s.Struct.Segment())
	if err != nil {
		return Addr{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s TrieMap) Branches() (Addr_List, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != branches")
	}
	p, err := s.Struct.Ptr(0)
	return Addr_List{List: p.List()}, err
}

func (s TrieMap) HasBranches() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s TrieMap) SetBranches(v Addr_List) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewBranches sets the branches field to a newly
// allocated Addr_List, preferring placement in s's segment.
func (s TrieMap) NewBranches(n int32) (Addr_List, error) {
	s.Struct.SetUint16(0, 1)
	l, err := NewAddr_List(s.Struct.Segment(), n)
	if err != nil {
		return Addr_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// TrieMap_List is a list of TrieMap.
type TrieMap_List = capnp.StructList[TrieMap]

// NewTrieMap creates a new list of TrieMap.
func NewTrieMap_List(s *capnp.Segment, sz int32) (TrieMap_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[TrieMap]{List: l}, err
}

// TrieMap_Future is a wrapper for a TrieMap promised by a client call.
type TrieMap_Future struct{ *capnp.Future }

func (p TrieMap_Future) Struct() (TrieMap, error) {
	s, err := p.Future.Struct()
	return TrieMap{s}, err
}

func (p TrieMap_Future) Leaf() TrieMap_leaf_Future { return TrieMap_leaf_Future{p.Future} }

// TrieMap_leaf_Future is a wrapper for a TrieMap_leaf promised by a client call.
type TrieMap_leaf_Future struct{ *capnp.Future }

func (p TrieMap_leaf_Future) Struct() (TrieMap_leaf, error) {
	s, err := p.Future.Struct()
	return TrieMap_leaf{s}, err
}

func (p TrieMap_leaf_Future) Addr() Addr_Future {
	return Addr_Future{Future: p.Future.Field(1, nil)}
}

const schema_dc976fcd6fee6223 = "x\xda|TOh\x1cU\x1c\xfe}\xef\xcd\xba\x9b\x92" +
	"tf\x9c\x04T\x94\x0aZ\xda\x04\xb3V\xaa\x14\x16%" +
	"15\xa5\x95$\xeck\xaa\xf6P\xd0\xd9\xdd\xb7\xbbC" +
	"w\xe7\xad3#\xc6@\xc9A\x82\xffP\xe8\xc1?\x17" +
	"O\x82\xd2^BA\x0f\x1e*\x8d\xa0\xd0R\x0f\x82B" +
	"\x05A\x85\xfa\x07\x0f\x1e\xbc\x08=\xf4\xc9\x9b\xdd\x9d\xdd" +
	"n\x8d\xb7\x9d\xc7\xf7~\xdf\xf7\xbe\xef\xfb\xed\x81\x1b\x98" +
	"\xb7\x1e\x99x-GL\xcc\xe7\xee\xd0\x0b'\x7f\xda\xff" +
	"\xf5\xf6\x87g\xc9u,\xfd@\xe5/\xf5\x8dz\xffG" +
	"\"\x1c<\xc7f\xe0}\xce\xf2D\xab\x9f2\x8e\xd5K" +
	"\x8c\x81H\xbf\xfe\xcb\xab\xde\x99\x9b\x8d\x0fH\xdc\x05\xe8" +
	"\x7f\x0e]\xbbt\xf8\x1du\x95\xa6X\x1eD\xde\x05\xf6" +
	"'\xc1\xfb\x8c\xbdL\xd0\x9b\xbf\xbd\xb9\xf0\xf0\xfa\xf9\x8f" +
	"H\xdc\x0d\xe8?\x1e\x7fl\xef\xbe#G\xaf\xd1\x14R" +
	"\xa4\xcb\xff&xS|\x8b\xa0\x8bOl\xbd\x15}\xf2" +
	"\xeb9r\x1dv\x8b\x86\x0b\xfcNx\xdb<O\xe4]" +
	"\xe4\x87\x08\xfa\xaa\xb3\xef\xc5/6'\xb7\xccL\xae\xfd" +
	"]\xd77\x9e\x8b\xde\xfb\xb9\xc7~p\x9b\xef\x02\xc1\xbb" +
	"\xcc\x0d}&M8\xc0`\xea\"\xcb3\"o\xaf\xf5" +
	"\xa57k\x99\xc1\xd3\x96Ag\xf2F\xd0H\xd1g\xac" +
	"+\xde\x1b)z3Eg\xc4\xc2\x01\x1f\xa0s\xc6-" +
	"\xef\xb2u\xc5\xfb>\x05\x7fk\xfdN\xd0\xcf\x8c\xab\x1f" +
	"J\xf7=\x7f}\x04\x9c\"\xde\xce\x9d\xf7\xde\xcd\x99_" +
	"gs[\xb4\xa2kA|:NT\xc4e\xb1\xeaw" +
	"\xc2N\xc9|\xf8\x0dyDEm?yVFv\x1c" +
	"\xa8\xb0\x0c\xa0@\xcc-\x80\x90]a\xfd+'\xa2@" +
	".\xfb\x9d\xa2\xdd\x92~]\x14\xb8Ed\x81\xc8\x9d." +
	"\x11\x89\x079\xc4\x01\x06\x17\x98\x849\x9c\x9d!\x12\xfb" +
	"9\xc4\xa3\x0cs\x9dH\xd6\x835L\x10\xc3\x04\xc1\xf6" +
	"k\xb5\x08\xce@?\x01\xce\x7f\x11.\xa9\xc6b\x98D" +
	"\xaf\xec)VZ\xaa\"\xc63\xc6\xc5\x05\"1\xcf!" +
	"\x96z\x8c\x8c\xc8=V!\x12G9\xc4\x09\x06\x97\xdd" +
	"?\x09N\xe4\x0a\xa3m\x89C\x9cd\xd8\x88e\xa3-" +
	"\xc3\xa4\xafCWU\xbb\x13\xc98\xa6|\xa0B\xd8\x83" +
	"\xba\x10`\x13\xe6:~\xf5\xb4\xac\x01\xc40lH\xe6" +
	"\xe1\xe1\xde\xfd@\x85\xab\xd5\xa6lC\x96\x01QH\xd5" +
	"\xb83f\x8a;v\x0f\x91\x1d\xaaP\xf2\xb5\xf5\xdb\x07" +
	",\xfbaP\x97qRl\xf9q\xb2\xa4\x1aD][" +
	"\xbb\x0f\x9a\x9e\x19\xf1\xd5<h\xb64\xf0\xd5\x8e\x83u" +
	"\x891b\x18#\xcc\x85/\xb5+2\xea\x7f\xee\x18\x1f" +
	"\xa5\x1a\xb95\xae50\xd8:\xc3\xc6&pSw\xb9" +
	"\xdd\xa7\x89\x84\xc3!\x1ebH\xf3\xd6\x95\xc8\x0f\xabM" +
	"\x19\x13\x11v\x13\xca\x1c#\x11\xee\xfe\xbf\x08\xe9V\xda" +
	"l\x85\x87hM\xb0\xee\xf1\x1e\xed\xbd\x0c\xb6\x09]\x07" +
	"aM\xae\xad\xa8\x1aA\xc2\x19\xec\xdeN\x95\xe9;\xda" +
	"\xe5s\xb8\x05\xa4\x8d\xf1McNq\x88\xa6)G\xaf" +
	"\xa3\xd2\x18\xfc\x02\x87h1\x80c\xe8_\xc0\x0d\x16\x88" +
	"9\xd6$,\xd3\xa1\x88H\x949\xc4)\x86\x0d#j" +
	"\xd9\xef\xdc^_;R*\x81\xa3?\x8en4\xbf[" +
	"\xbf\xf8U\xefx\xa3\x17\xad\xae\xf76\x8d\xf6D\xa60" +
	"f\xcfP\x18z\x02\xfaO\xb0\x9f\xac\xd5\"\xa3~<" +
	"S\xbfX\x1a\xea;c]\xf5\xc7\xcc\xe1S\x1c\xa2\xcc" +
	"\xe0\xb0nl\xcb\xc7\x07u\x9fS\xf5z,\x93\xac\x1f" +
	"-\x196\x92f\xc6\xdbR\x8d\x15\xd3\x18B\xd6\x99\x7f" +
	"\x03\x00\x00\xff\xff\xa3\x92\x82\xb1"

func init() {
	schemas.Register(schema_dc976fcd6fee6223,
		0x919dc1c628df5842,
		0x9867fe7d1383e188,
		0xa3aa7a2f428ae685,
		0xa9e5a7728baf3d2e,
		0xaf1485be712710cc,
		0xcc6f8e43c0d837f7,
		0xd848462725353ce8,
		0xe09672577fe40a61,
		0xe45f1d3ad96f0c55)
}
