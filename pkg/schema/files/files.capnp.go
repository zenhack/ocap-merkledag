// Code generated by capnpc-go. DO NOT EDIT.

package files

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	strconv "strconv"
	protocol "zenhack.net/go/ocap-md/pkg/schema/protocol"
)

type File struct{ capnp.Struct }
type File_metadata File
type File_Which uint16

const (
	File_Which_file    File_Which = 0
	File_Which_dir     File_Which = 2
	File_Which_symlink File_Which = 1
)

func (w File_Which) String() string {
	const s = "filedirsymlink"
	switch w {
	case File_Which_file:
		return s[0:4]
	case File_Which_dir:
		return s[4:7]
	case File_Which_symlink:
		return s[7:14]

	}
	return "File_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

type File_metadata_Which uint16

const (
	File_metadata_Which_noMetadata   File_metadata_Which = 0
	File_metadata_Which_unixMetadata File_metadata_Which = 1
)

func (w File_metadata_Which) String() string {
	const s = "noMetadataunixMetadata"
	switch w {
	case File_metadata_Which_noMetadata:
		return s[0:10]
	case File_metadata_Which_unixMetadata:
		return s[10:22]

	}
	return "File_metadata_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// File_TypeID is the unique identifier for the type File.
const File_TypeID = 0xc4abcc30dd3a9483

func NewFile(s *capnp.Segment) (File, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return File{st}, err
}

func NewRootFile(s *capnp.Segment) (File, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return File{st}, err
}

func ReadRootFile(msg *capnp.Message) (File, error) {
	root, err := msg.Root()
	return File{root.Struct()}, err
}

func (s File) String() string {
	str, _ := text.Marshal(0xc4abcc30dd3a9483, s.Struct)
	return str
}

func (s File) Which() File_Which {
	return File_Which(s.Struct.Uint16(0))
}
func (s File) Metadata() File_metadata { return File_metadata(s) }

func (s File_metadata) Which() File_metadata_Which {
	return File_metadata_Which(s.Struct.Uint16(2))
}
func (s File_metadata) SetNoMetadata() {
	s.Struct.SetUint16(2, 0)

}

func (s File_metadata) UnixMetadata() (UnixMetadata, error) {
	if s.Struct.Uint16(2) != 1 {
		panic("Which() != unixMetadata")
	}
	p, err := s.Struct.Ptr(1)
	return UnixMetadata{Struct: p.Struct()}, err
}

func (s File_metadata) HasUnixMetadata() bool {
	if s.Struct.Uint16(2) != 1 {
		return false
	}
	return s.Struct.HasPtr(1)
}

func (s File_metadata) SetUnixMetadata(v UnixMetadata) error {
	s.Struct.SetUint16(2, 1)
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewUnixMetadata sets the unixMetadata field to a newly
// allocated UnixMetadata struct, preferring placement in s's segment.
func (s File_metadata) NewUnixMetadata() (UnixMetadata, error) {
	s.Struct.SetUint16(2, 1)
	ss, err := NewUnixMetadata(s.Struct.Segment())
	if err != nil {
		return UnixMetadata{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s File) File() (BlobTree, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != file")
	}
	p, err := s.Struct.Ptr(0)
	return BlobTree{Struct: p.Struct()}, err
}

func (s File) HasFile() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s File) SetFile(v BlobTree) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewFile sets the file field to a newly
// allocated BlobTree struct, preferring placement in s's segment.
func (s File) NewFile() (BlobTree, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewBlobTree(s.Struct.Segment())
	if err != nil {
		return BlobTree{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s File) Dir() protocol.Ref {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != dir")
	}
	p, _ := s.Struct.Ptr(0)
	return protocol.Ref{Client: p.Interface().Client()}
}

func (s File) HasDir() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s File) SetDir(v protocol.Ref) error {
	s.Struct.SetUint16(0, 2)
	if !v.Client.IsValid() {
		return s.Struct.SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client))
	return s.Struct.SetPtr(0, in.ToPtr())
}

func (s File) Symlink() (string, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != symlink")
	}
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s File) HasSymlink() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s File) SymlinkBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s File) SetSymlink(v string) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetText(0, v)
}

// File_List is a list of File.
type File_List = capnp.StructList[File]

// NewFile creates a new list of File.
func NewFile_List(s *capnp.Segment, sz int32) (File_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[File]{l}, err
}

// File_Future is a wrapper for a File promised by a client call.
type File_Future struct{ *capnp.Future }

func (p File_Future) Struct() (File, error) {
	s, err := p.Future.Struct()
	return File{s}, err
}

func (p File_Future) Metadata() File_metadata_Future { return File_metadata_Future{p.Future} }

// File_metadata_Future is a wrapper for a File_metadata promised by a client call.
type File_metadata_Future struct{ *capnp.Future }

func (p File_metadata_Future) Struct() (File_metadata, error) {
	s, err := p.Future.Struct()
	return File_metadata{s}, err
}

func (p File_metadata_Future) UnixMetadata() UnixMetadata_Future {
	return UnixMetadata_Future{Future: p.Future.Field(1, nil)}
}

func (p File_Future) File() BlobTree_Future {
	return BlobTree_Future{Future: p.Future.Field(0, nil)}
}

func (p File_Future) Dir() protocol.Ref {
	return protocol.Ref{Client: p.Future.Field(0, nil).Client()}
}

type UnixMetadata struct{ capnp.Struct }

// UnixMetadata_TypeID is the unique identifier for the type UnixMetadata.
const UnixMetadata_TypeID = 0xeab612050895537a

func NewUnixMetadata(s *capnp.Segment) (UnixMetadata, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return UnixMetadata{st}, err
}

func NewRootUnixMetadata(s *capnp.Segment) (UnixMetadata, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return UnixMetadata{st}, err
}

func ReadRootUnixMetadata(msg *capnp.Message) (UnixMetadata, error) {
	root, err := msg.Root()
	return UnixMetadata{root.Struct()}, err
}

func (s UnixMetadata) String() string {
	str, _ := text.Marshal(0xeab612050895537a, s.Struct)
	return str
}

func (s UnixMetadata) Permissions() uint32 {
	return s.Struct.Uint32(0)
}

func (s UnixMetadata) SetPermissions(v uint32) {
	s.Struct.SetUint32(0, v)
}

func (s UnixMetadata) ModTime() int64 {
	return int64(s.Struct.Uint64(8))
}

func (s UnixMetadata) SetModTime(v int64) {
	s.Struct.SetUint64(8, uint64(v))
}

// UnixMetadata_List is a list of UnixMetadata.
type UnixMetadata_List = capnp.StructList[UnixMetadata]

// NewUnixMetadata creates a new list of UnixMetadata.
func NewUnixMetadata_List(s *capnp.Segment, sz int32) (UnixMetadata_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[UnixMetadata]{l}, err
}

// UnixMetadata_Future is a wrapper for a UnixMetadata promised by a client call.
type UnixMetadata_Future struct{ *capnp.Future }

func (p UnixMetadata_Future) Struct() (UnixMetadata, error) {
	s, err := p.Future.Struct()
	return UnixMetadata{s}, err
}

type BlobTree struct{ capnp.Struct }
type BlobTree_Which uint16

const (
	BlobTree_Which_leaf   BlobTree_Which = 0
	BlobTree_Which_branch BlobTree_Which = 1
)

func (w BlobTree_Which) String() string {
	const s = "leafbranch"
	switch w {
	case BlobTree_Which_leaf:
		return s[0:4]
	case BlobTree_Which_branch:
		return s[4:10]

	}
	return "BlobTree_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// BlobTree_TypeID is the unique identifier for the type BlobTree.
const BlobTree_TypeID = 0xfde2c325eeeb9f0a

func NewBlobTree(s *capnp.Segment) (BlobTree, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return BlobTree{st}, err
}

func NewRootBlobTree(s *capnp.Segment) (BlobTree, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return BlobTree{st}, err
}

func ReadRootBlobTree(msg *capnp.Message) (BlobTree, error) {
	root, err := msg.Root()
	return BlobTree{root.Struct()}, err
}

func (s BlobTree) String() string {
	str, _ := text.Marshal(0xfde2c325eeeb9f0a, s.Struct)
	return str
}

func (s BlobTree) Which() BlobTree_Which {
	return BlobTree_Which(s.Struct.Uint16(0))
}
func (s BlobTree) Leaf() protocol.Ref {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != leaf")
	}
	p, _ := s.Struct.Ptr(0)
	return protocol.Ref{Client: p.Interface().Client()}
}

func (s BlobTree) HasLeaf() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s BlobTree) SetLeaf(v protocol.Ref) error {
	s.Struct.SetUint16(0, 0)
	if !v.Client.IsValid() {
		return s.Struct.SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client))
	return s.Struct.SetPtr(0, in.ToPtr())
}

func (s BlobTree) Branch() protocol.Ref {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != branch")
	}
	p, _ := s.Struct.Ptr(0)
	return protocol.Ref{Client: p.Interface().Client()}
}

func (s BlobTree) HasBranch() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	return s.Struct.HasPtr(0)
}

func (s BlobTree) SetBranch(v protocol.Ref) error {
	s.Struct.SetUint16(0, 1)
	if !v.Client.IsValid() {
		return s.Struct.SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client))
	return s.Struct.SetPtr(0, in.ToPtr())
}

func (s BlobTree) Size() uint64 {
	return s.Struct.Uint64(8)
}

func (s BlobTree) SetSize(v uint64) {
	s.Struct.SetUint64(8, v)
}

// BlobTree_List is a list of BlobTree.
type BlobTree_List = capnp.StructList[BlobTree]

// NewBlobTree creates a new list of BlobTree.
func NewBlobTree_List(s *capnp.Segment, sz int32) (BlobTree_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[BlobTree]{l}, err
}

// BlobTree_Future is a wrapper for a BlobTree promised by a client call.
type BlobTree_Future struct{ *capnp.Future }

func (p BlobTree_Future) Struct() (BlobTree, error) {
	s, err := p.Future.Struct()
	return BlobTree{s}, err
}

func (p BlobTree_Future) Leaf() protocol.Ref {
	return protocol.Ref{Client: p.Future.Field(0, nil).Client()}
}

func (p BlobTree_Future) Branch() protocol.Ref {
	return protocol.Ref{Client: p.Future.Field(0, nil).Client()}
}

const schema_ae1c58020a8c26ad = "x\xda\x94\x92?h\x14[\x14\xc6\xbf\xef\xde\x99\xddI" +
	"\xd8y\xbb\xf7\xcd>\x1e\x0f\x9e\x08\x82\xd1H\x08Y\xb0" +
	"\x90 \x18\x02Q\x11\xff\xec\xc5\x04\x82Dp\x92\x9d\x90" +
	"\xd1\xfd\x13w7\xe8\x06!\x85\x9dXX\x18\xb1\x13K" +
	"\x15\x95\x14\x8a\x85\x82`\x0a\x11+\xb1M\xa3\x85\xa0`" +
	"m\x93\xbdr'\xab\xbb\xa6K7\x9c\xf9\xce\xfd\xce\xf9" +
	"~g\xc4p\xcc)\xf8\xc7<\x08}\xc1M\x99\xd3\xea" +
	"\xb3>\xde^[\x85V\xa4\xb9~{tc\xe4\xfd\xa3" +
	"uL\x894\x05\x19\xf49\x1f\xc0\xc0w\xae\xa0\xe7\xa7" +
	"\xce\x90\xe6\xf1\xc0\xcd~1\xfd\xff\x13L\x88\xb4\x04\x82" +
	"\xcb\xce\x8d\xa0\xe5\xa4\x81`\xc9\xf9\x02\x9a\xe5\xb3\xab\x9e" +
	"\xfb\xf7\xf3\xafV-\xba\xeaD\xf1\xc0}\x17<s\xed" +
	"\xd7\x9ak_\xee\xbf\xf7\xed\xfb\xde7\x9f6\xb7i'" +
	"\x98\x16@\xa0R\x0f\x83\xffRV\xfdO\xea)6\xcc" +
	"|\\\x8e\x1a\xc3s\xa1X\xac.\x8e\x1e\x8d\xcb\xd1p" +
	"%j\x86\xa5\xb0\xc9P{\xd2\xc9\x18\x93'\x015x" +
	"\x0e\xd0\xfb%\xf5A\xc1]l\x1b\xe6)\x01U\xb8\x08" +
	"\xe8\x11I}X\xd0Tk\xa7\x92^\xc8f\x88\x94Y" +
	"\xaa\xc6Wm\x01\xd9R\xd8\x0c\x99\xebn\x012\x07\xfe" +
	"\xf6\xe6/o\xa0H\xea\x9ct|\x1a\xe3X\xdb\xf0\x00" +
	"\xa0g$\xf5\x82\xa0m\xebF\xac\xa2\x13\x10\xbel\x9b" +
	"<\x05\xa0\xf48\xa0OJ\xeaiA_l\x9a<\x1d" +
	"@M\xed\x01tQR\x7f\x14\xccZ;\xe6\xba\xf9t" +
	"\xa6\xe8\xec\x1b\x02Xi\xb4*\xe5\xb8z\x89\x19\x08f" +
	"\xc0t)\xaeS\x99\xc2\xcb\xf3\xad\xca\xe6\x99\xfb\x00\xc6" +
	"\xa8\xb8[;\x82\xbdE\xc5\x7f\xb5C\x92EI\xe6\xcc" +
	"\xad\xb73?\xee\x0e\x0d\xdc\xf9C\xdeST\xdc\xa7=" +
	"+\xd7\x9ed\xb2/\x13\xc3\\\xf7(@\xaa\x9e\x80\x12" +
	"8S\x9d8\xb7f-&\xed\x0e\x90\xc448\xdb\xa5" +
	"\xa3\xc8-d\x05\x1b\xc9\x90\xa4>$h\x16\xa3z%" +
	"n4b\xa4k\xd5\x06=\x08z\xe0J\xa5V\x9a\x8c" +
	"+\x11]\x08\xba\xdb\x89\x8c\x97k\xb3\xd9\xc9z\x14Y" +
	"\xafLr\x0b\x89\xd9\x84e2&\xa9\xaf\x09\xfalw" +
	"\x0e\xa45\x0a\xe8\xa6\xa4~-\xa8\x04\xb7\xa8\xbc\xb2\xd2" +
	"\x17\x92z]0[\x8e\xc2\xf9\x9d\xa6\xe9C\xd8$\x8e" +
	"\xcc\xd6\xc3\xea\xdc\xc2N\xbb\xffB\x07I/s\x05f" +
	"\x1b\xf1r\xc4>\x08\xf6\x81?\x03\x00\x00\xff\xff>s" +
	"\xf3R"

func init() {
	schemas.Register(schema_ae1c58020a8c26ad,
		0x95b1fe4851e3114e,
		0xc4abcc30dd3a9483,
		0xeab612050895537a,
		0xfde2c325eeeb9f0a)
}
